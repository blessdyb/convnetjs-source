/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @format
 *
 */
"use strict";

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly &&
      (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })),
      keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2
      ? ownKeys(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(
          target,
          Object.getOwnPropertyDescriptors(source)
        )
      : ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(
            target,
            key,
            Object.getOwnPropertyDescriptor(source, key)
          );
        });
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var CharacterMetadata = require("./CharacterMetadata");

var ContentBlock = require("./ContentBlock");

var ContentBlockNode = require("./ContentBlockNode");

var Immutable = require("immutable");

var convertFromHTMLtoContentBlocksClassic = require("./convertFromHTMLToContentBlocks");

var convertFromHTMLtoContentBlocksNew = require("./convertFromHTMLToContentBlocks2");

var convertFromRawToDraftState = require("./convertFromRawToDraftState");

var generateRandomKey = require("./generateRandomKey");

var getSafeBodyFromHTML = require("./getSafeBodyFromHTML");

var gkx = require("./gkx");

var sanitizeDraftText = require("./sanitizeDraftText");

var List = Immutable.List,
  Repeat = Immutable.Repeat;
var experimentalTreeDataSupport = gkx("draft_tree_data_support");
var ContentBlockRecord = experimentalTreeDataSupport
  ? ContentBlockNode
  : ContentBlock;
var refactoredHTMLImporter = gkx("draft_refactored_html_importer");
var convertFromHTMLtoContentBlocks = refactoredHTMLImporter
  ? convertFromHTMLtoContentBlocksNew
  : convertFromHTMLtoContentBlocksClassic;
var DraftPasteProcessor = {
  processHTML: function processHTML(html, blockRenderMap) {
    var body = getSafeBodyFromHTML(html);
    var fragmentElt = body && body.querySelector("[data-editor-content]");
    var fragmentAttr =
      (fragmentElt && fragmentElt.getAttribute("data-editor-content")) || null; // Handle the paste without converting the HTML if it comes from another Draft.js editor.

    if (fragmentAttr) {
      var rawContent;

      try {
        // If JSON parsing fails, handle the paste as normal HTML.
        rawContent = JSON.parse(fragmentAttr);
      } catch (error) {}

      if (rawContent) {
        var content = convertFromRawToDraftState(rawContent);
        return {
          contentBlocks: content.getBlocksAsArray(),
          entityMap: content.getEntityMap(),
        };
      }
    }

    return convertFromHTMLtoContentBlocks(
      html,
      getSafeBodyFromHTML,
      blockRenderMap
    );
  },
  processText: function processText(textBlocks, character, type) {
    return textBlocks.reduce(function (acc, textLine, index) {
      textLine = sanitizeDraftText(textLine);
      var key = generateRandomKey();
      var blockNodeConfig = {
        key: key,
        type: type,
        text: textLine,
        characterList: List(Repeat(character, textLine.length)),
      }; // next block updates previous block

      if (experimentalTreeDataSupport && index !== 0) {
        var prevSiblingIndex = index - 1; // update previous block

        var previousBlock = (acc[prevSiblingIndex] = acc[
          prevSiblingIndex
        ].merge({
          nextSibling: key,
        }));
        blockNodeConfig = _objectSpread(
          _objectSpread({}, blockNodeConfig),
          {},
          {
            prevSibling: previousBlock.getKey(),
          }
        );
      }

      acc.push(new ContentBlockRecord(blockNodeConfig));
      return acc;
    }, []);
  },
};
module.exports = DraftPasteProcessor;
