"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.default = generateImageServiceUrl;

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(
          target,
          key,
          Object.getOwnPropertyDescriptor(source, key)
        );
      });
    }
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

/**
 * Generates a URL for the node image service (https://github.com/asilvas/node-image-steam) that applies the given
 * edits and cropping to the image. You can achieve resize without cropping (i.e. a max-width or max-height resize
 * preserving the aspect ratio) by only specifying the outputWidth or the outputHeight.
 *
 * @param {object} options Object containing various properties related to image data.
 * @param {object} editData object is a legacy parameter which is merged into the options parameter.

 * The merged object of options and editData (mergedParameters)
 * @param {string} mergedParameters.imageUrl The base image URL.
 * @param {number} mergedParameters.outputWidth The width (in pixels) desired for the resulting image.
 * @param {number} mergedParameters.outputHeight The height (in pixels) desired for the resulting image.
 * @param {boolean} mergedParameters.ignoreAspect Ignore aspect ratio and will render image with specified outputWidth and outputHeight
 * @param {boolean} mergedParameters.canGrow Indicates whether to allow the image to stretch to the target size.
 * @param {array} mergedParameters.additionalUrlParams An additional pre-resolved string parameter that is appended to the image's url.
 * @param {string} mergedParameters.rotation The rotation value in degrees for the image, must be an increment of 90 degrees.
 * @param {string} mergedParameters.top The top offset of where to crop the image (percentage or pixels).
 * @param {string} mergedParameters.left The left offset of where to crop the image (percentage or pixels).
 * @param {string} mergedParameters.width The width of the desired crop (percentage or pixels).
 * @param {string} mergedParameters.height The height of the desired crop (percentage or pixels).
 * @param {string} mergedParameters.aspectRatio The aspect ratio of the original crop operation.
 * @param {number} mergedParameters.quality The quality of the image (1-100, low to high)
 * @param {boolean} mergedParameters.enableImageDimension Indicates whether image dimension is enabled or not
 * @param {string} mergedParameters.imageDimension Indicates which image dimension customer selected
 * @returns {string} The resulting image URL with the cropping and edits applied.
 */
function generateImageServiceUrl() {
  var options =
    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var editData =
    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var mergedParameters = _objectSpread(_objectSpread({}, options), editData);

  var imageUrl = mergedParameters.imageUrl,
    _mergedParameters$can = mergedParameters.canGrow,
    canGrow = _mergedParameters$can === void 0 ? true : _mergedParameters$can,
    ignoreAspect = mergedParameters.ignoreAspect,
    _mergedParameters$add = mergedParameters.additionalUrlParams,
    additionalUrlParams =
      _mergedParameters$add === void 0 ? [] : _mergedParameters$add,
    enableImageDimension = mergedParameters.enableImageDimension,
    imageDimension = mergedParameters.imageDimension;
  var filteredValues = filterNaNValues(mergedParameters);
  var outputWidth = filteredValues.outputWidth,
    outputHeight = filteredValues.outputHeight,
    aspectRatio = filteredValues.aspectRatio,
    quality = filteredValues.quality;
  var rotation = filteredValues.rotation,
    left = filteredValues.left,
    top = filteredValues.top,
    width = filteredValues.width,
    height = filteredValues.height;
  var output = [];
  var editAspectRatio = parseFloat(aspectRatio || 0);
  var requestedAspectRatio =
    outputWidth && outputHeight ? outputWidth / outputHeight : editAspectRatio;
  var isSameAspectRatio =
    Math.abs(editAspectRatio - requestedAspectRatio) < 0.05;

  if (enableImageDimension || !imageDimension) {
    // Apply rotation
    rotation = parseInt(rotation || 0, 10);

    if (rotation) {
      output.push("rt=d:".concat(rotation));
    }

    var resizeOptions = computeResizeOptions(canGrow, true, ignoreAspect);

    if (isSameAspectRatio) {
      // A crop width or height that is > 100% indicates that the image was zoomed out by the user. To accommodate this use
      // case, we want to do a 100% crop and resize the resulting image without using the 'm' (minimum) parameter.
      if (parseInt(height, 10) >= 100 && height.indexOf("%") > -1) {
        height = "100%";
        top = "0%";
        resizeOptions = computeResizeOptions(canGrow, false, ignoreAspect);
      }

      if (parseInt(width, 10) >= 100 && width.indexOf("%") > -1) {
        width = "100%";
        left = "0%";
        resizeOptions = computeResizeOptions(canGrow, false, ignoreAspect);
      }
    }

    var resize;

    if (outputWidth && outputHeight) {
      resize = "rs=w:"
        .concat(outputWidth, ",h:")
        .concat(outputHeight)
        .concat(resizeOptions);
    } else if (outputHeight) {
      resize = "rs=h:".concat(outputHeight).concat(resizeOptions);
    } else if (outputWidth) {
      resize = "rs=w:".concat(outputWidth).concat(resizeOptions);
    } // If image edits were specified and the aspect ratio matches, crop and then resize to desired dimensions

    if (top && left && width && height && isSameAspectRatio) {
      output.push(
        "cr=t:"
          .concat(top, ",l:")
          .concat(left, ",w:")
          .concat(width, ",h:")
          .concat(height)
      );

      if (resize) {
        output.push(resize);
      }
    } else {
      // If no edits were specified or they are not valid for these dimensions, resize the image then crop it
      if (resize) {
        output.push(resize);
      }

      if (outputHeight && outputWidth) {
        output.push("cr=w:".concat(outputWidth, ",h:").concat(outputHeight));
      }
    }

    if (quality) {
      output.push("qt=q:".concat(quality));
    }
  }

  return (
    imageUrl +
    "/:/" +
    encodeURI(
      output
        .concat(
          additionalUrlParams.filter(function (param) {
            return param && param.length > 0;
          })
        )
        .join("/")
    )
  );
}

function computeResizeOptions(canGrow, forceMin, ignoreAspect) {
  return canGrow
    ? ",cg:true"
        .concat(forceMin ? ",m" : "")
        .concat(ignoreAspect ? ",i:true" : "")
    : "";
}

function filterNaNValues(object) {
  var _object$outputWidth = object.outputWidth,
    outputWidth = _object$outputWidth === void 0 ? 0 : _object$outputWidth,
    _object$outputHeight = object.outputHeight,
    outputHeight = _object$outputHeight === void 0 ? 0 : _object$outputHeight,
    aspectRatio = object.aspectRatio,
    quality = object.quality,
    rotation = object.rotation,
    left = object.left,
    top = object.top,
    _object$width = object.width,
    width = _object$width === void 0 ? "" : _object$width,
    _object$height = object.height,
    height = _object$height === void 0 ? "" : _object$height;
  return (0, _lodash.pickBy)(
    {
      outputWidth: outputWidth,
      outputHeight: outputHeight,
      aspectRatio: aspectRatio,
      quality: quality,
      rotation: rotation,
      left: left,
      top: top,
      width: width,
      height: height,
    },
    function (value) {
      return !isNaN(parseInt(value, 10));
    }
  );
}
